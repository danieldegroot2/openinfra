---
title: "Transport Infrastructure Data Packs"
author: "James Hulse"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Transport Infrastructure Data Packs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data Packs

This vignette covers the recategorisation of OpenStreetMap (OSM) infrastructure data into the openinfra transport infrastructure data packs.
<br><br>
To view the current publication of our data packs, please see the Openinfra GitHub repository releases page [here](https://github.com/udsleeds/openinfra/releases). 
<br><br>
The transport infrastructure data packs contain OSM infrastructure data for a given Local Authority District (LAD), as defined by the following polygons for [UK LADs](https://github.com/udsleeds/openinfra/blob/main/data-small/lads_joined_2021.geojson). 
<br><br>
Whilst these LADs are currently being used to define the spatial area covered by each infrastructure data pack, any new set of updated boundaries (as a geojson file) can also be used to create the transport infrastructure data packs. 
<br><br>

The LADs can be seen below: <br>

```{r, echo=FALSE, include=TRUE, out.width="650px"}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/LADs_of_the_UK_new.html", height = "650px")
```

## Current Data Pack Visualisation Examples

<br><br>
This sections visualises the data pack outputs generated by the openinfra functions that are described in detail below.

The current example data pack outputs for a 2km circular radius about "Leeds" City Centre: <br><br>
-- Cleaned road descriptions <br>
-- Legally cyclable network <br>
-- Legally walkable network <br>
-- Presence of lighting network <br>
-- Cleaned maximum speed values <br>
-- Presence of cycle crossings <br>
-- Presence of cycle parking <br>
-- Recategorised road names <br>
<br><br>

### Default OSM Highways

Please note that a 2Km circular buffer has been applied to the data so that the map can be hosted on this website. (max size 25Mb)<br>
As can be seen, the default network has a variety of `highway` values and is rather confusing to the uninitiated OSM user. 
<br>
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/deault_OSM_highways.html", height = "650px")
```
<br><br>

### Recategorised Road Descriptions
The recategorised road descriptions are more interpenetrate and meaningful than the default OSM highway values.

```{r visualisation_frame, out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/road_desc_map.html", height = "650px")
```
As can be seen - the OSM highways recategorised to road descriptions are much easier to visualise and insightful than all OSM highway values.
<br><br>

### Recategorised Cyclable Ways
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/active_cycle_map.html", height = "650px")
```
This visualisation shows the ways that cyclist legally have a right to access and use - note that this does not imply a "friendly" or "super safe" route, more that cyclists can use such ways if required.
<br><br>
An example application of this dataset could be highlighting the most likely roads that will be used by cyclists when switching from (intermittent) dedicated cycling infrastructure.

<br><br>

### Recategorised Walkable Ways
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/active_walk_map.html", height = "650px")
```
<br>Much like the cycleable ways visualisation above, this visualisation shows ways that pedestrians legally have a right of way on. It does not assess or indicate any "friendliness" or "scenic-ness" of a way.
<br><br>

### Recategorised Presence of Street Lighting
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/is_lit_map.html", height = "650px")
```
Note that a value of `maybe` implies the lack of data to distinguish between `"yes"` or `"no"`.
<br><br>
Such information may be utilised to assess routes for safe active travel after dark. Likewise, complimented with Origin Destination (OD) data, one may identify active travel routes along high active travel traffic ways and implement lighting (if not present) to increase the safety of such routes after dark.

<br><br>

### Cleaned Maximum Speeds (UK)
```{r vis_frame, out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/clean_maxspeed_map.html", height = "650px")
```
Recategorised UK maximum road speed values. Based on the official [UK speed limits](https://www.gov.uk/speed-limits).
<br><br>

### Presence of Cycle Crossings
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/cycle_crossings_map.html", height = "650px")
```
Identifies the presence of cycle crossings based on OSM data.
<br><br>

### Presence of Cycle Parking
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/cycle_parking_map.html", height = "650px")
```
Identifies the presence of cycle parking facilities based on OSM data.
<br><br>

### Recategorised Road Names
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/road_namesmap.html", height = "650px")
```
Recategorises OSM to provide more descriptive road names useful for discussion and targeted analysis. 
<br><br>
For example, [`osm_id:23200835`](https://www.openstreetmap.org/way/23200835) is less useful as a name than, `Lovell Park Road`
<br><br>

### Dedicated Cycling Infrastructure 
```{r out.width="100%", echo=FALSE, include=TRUE}
knitr::include_url("https://udsleeds.github.io/openinfraresults/tmap/assets/cycle_infra_map.html", height = "650px")
```
This function identifies the type of cycling infrastructure, with respect to the level of separation from carriageways, from OSM data. 
Such infrastructure consists of on carriageway infrastructure (cycling lanes, mixed traffic, shared busway/lanes) and protected infrastructure (cycle tracks and ways, stepped cycleways, kerb separated cycleways) where _protected_ implies some form of physical separation from the carriageway. 

## Data Pack Production Workflow

The English data pack outputs, with examples visualised above, are produced using the following, reproducible, workflow: 

- **1.** Download OSM data file for entirety of England <br><br>
- **2.** For each [LAD](https://udsleeds.github.io/openinfra/articles/regions.html#interactive-map-of-local-authorities) polygon, get the OSM points & lines data from the previously downloaded England file & save each LAD default points lines network locally <br><br>
- **3.** For each LAD points & lines network saved locally, load the network and apply the openinfra functions, recategorising the OSM data <br><br>
- **4.** Save the newly created points & lines data packs locally, before uploading to GitHub releases <br><br>
- **5.** Repeat **2 - 4** for each LAD within England

The workflow described above is contained within the [create_data_packs.R](https://github.com/udsleeds/openinfra/blob/main/code/create_data_packs.R) script. <br><br>
For ease of use, and segmenting long computation times, the above script has been split in two - [create_LAD_networks.R](https://github.com/udsleeds/openinfra/blob/main/code/create_LAD_networks.R) performing steps 1-2, and [create_upload_data_packs.R](https://github.com/udsleeds/openinfra/blob/main/code/create_upload_data_packs.R) for steps 3-4.

## Data Pack Column Definitions

This section defines the column names contained within each LAD data pack added by the [openinfra](https://udsleeds.github.io/openinfra/reference/index.html) functions.

|column name|column description|
|-----------|------------------|
|openinfra_cycle|Indicates if an OSM way is legally usable by cyclists <br><br> Note: this does not assess any "qualities" of a way (such as quietness, traffic flows etc.)|
|openinfra_walk|Indicates if an OSM way is legally usable by pedestrians <br><br> Note: this does not assess any "qualities" of a way (such as quietness, traffic flows etc.)|
|openinfra_cycle_parking|Identifies bicycle parking places from OSM data `amenity` tag|
|openinfra_maxspeed|Reclassified default OSM `maxspeed` column values to be compliant with current [UK speed limits](https://www.gov.uk/speed-limits)|
|openinfra_cycle_crossings|Identifies OSM ways used specifically for cycles to cross carriageways|
|openinfra_cycle_infra|Reclassifies default OSM data to identify the 'high-level' type of protection provided by dedicated cycling infrastructure, such as: <br><br>Mixed Traffic (=< 20 mph) - _no protection_,<br><br> Cycle Lanes (mandatory & advisory) - _legal protection_,<br><br> Protected Cycling Spaces - _physical protection_, <br><br> including: stepped cycleways, kerb separated cycleways, cycle tracks, etc.|
|openinfra_is_lit|Identifies if an OSM way has lighting present or not, or if there is a lack of data to accurately assess ("maybe")|
|openinfra_road_class|Reclassifies default OSM `highway` values to relevant UK highway classifications, with modifications used by [Chan and Cooper](https://www.nature.com/articles/s41598-019-55669-8)|
|openinfra_road_names|Identifies the road name and reference (where available) of OSM ways and combines these to be more informative.<br> i.e. `osm_id=4004413` --> Headingly Lane, A660|

## Example Data Pack Production - Leeds

Here we go over a reproducible example of generating a transport infrastructure data pack from a OSM network retrieved using [`osmextract`](https://github.com/ropensci/osmextract), the outputs of which have been visualised abbove. 


<br><br>
This example concerns the LAD of Leeds, UK. <br>
Note that a 2km circular buffer has been applied (centered at Long, Lat coords (-1.548567, 53.801277)) to reduce map filesize so that the visualisations above can be hosted on this webpage.
<br><br>

### Getting Data
```{r download_data}
# Data downloaded through osmextract as shown below: 

#total_place = osmextract::oe_get(
#  place = "Leeds",
#  provider = "bbbike",
#  layer = "lines",
#  never_skip_vectortranslate = TRUE,
#  force_download = TRUE,
#  quiet = FALSE,
#  extra_tags = c("foot", "bicycle", "access", "service", "maxspeed", "oneway",
#                  "kerb", "footway", "sidewalk", "cycleway", "segregated", 
#                  "highway", "crossing", "lit", "tactile_paving", "surface", 
#                  "smoothness", "width", "est_width", "lit_by_led", "ref", 
#                  "amenity")
#)

# For reproduciblity you may chose to use the example dataset from our releases.
# You can create your own data using the oe_get() function above.
leeds_lines_network = sf::read_sf("https://github.com/udsleeds/openinfra/releases/download/0.4.2/leeds_lines_network.geojson")
leeds_points_network = sf::read_sf("https://github.com/udsleeds/openinfra/releases/download/0.4.2/leeds_points_network.geojson")
```

<br><br>

### Applying Openinfra Functions - Adding Value 
```{r function_application, eval=FALSE}
# First we apply relevant functions to the "lines" (roads, paths, etc.) layer 
leeds_lines_datapack = oi_active_cycle(leeds_lines_network)
leeds_lines_datapack = oi_active_walk(leeds_lines_datapack)
leeds_lines_datapack = oi_clean_maxspeed_uk(leeds_lines_datapack)
leeds_lines_datapack = oi_cycle_crossings(leeds_lines_datapack)
leeds_lines_datapack = oi_cycle_separation(leeds_lines_datapack)
leeds_lines_datapack = oi_is_lit(leeds_lines_datapack)
leeds_lines_datapack = oi_recode_road_class(leeds_lines_datapack)
leeds_lines_datapack = oi_road_names(leeds_lines_datapack)

# Now we create points data packs
leeds_points_datapack = oi_bicycle_parking(leeds_points_network)

```
<br><br>

### Selecting Relevant Columns for Data Pack
```{r, create_data_pack, eval=FALSE}
# Select relevant lines columns
leeds_lines_datapack = leeds_lines_datapack %>% dplyr::select(c(
 "osm_id", "highway", matches(match = "openinfra_|im_")))

# Append geometry as final column - good {sf} practice.
leeds_lines_datapack = sf::st_sf(
  leeds_lines_datapack %>% sf::st_drop_geometry(),
  geometry = leeds_lines_datapack$geometry)

# Select relevant points columns
leeds_points_datapack = leeds_points_datapack %>% dplyr::select(c(
  "osm_id", matches(match="openinfra_|im_")))

# Append geometry as final column - good {sf} practice.
leeds_points_datapack = sf::st_sf(
  leeds_points_datapack %>% sf::st_drop_geometry(),
  geometry = leeds_points_datapack$geometry)

```

### Example visualisation
```{r visualise_example_pack}
library(dplyr)

# Get data for cell
leeds_points_datapack = sf::read_sf("https://github.com/udsleeds/openinfra/releases/download/0.4.2/leeds_points_datapack.geojson")
# Remove NA 
leeds_points_datapack = leeds_points_datapack %>% dplyr::filter(! is.na(openinfra_cycle_parking)) 

#Visualise Data
tmap::tmap_mode("view")
tmap::tm_shape(leeds_points_datapack) + 
  tmap::tm_bubbles(col = "openinfra_cycle_parking", size=0.1)

```

Thus concludes the reproducible example creation of the transport infrastructure data packs.
<br><br>
Below we see how each of the openinfra functions has been defined, thus the processing steps applied to OSM data in data pack creation. 
<br><br>

## Data Packs: openinfra Function Definitions

This section covers the current openinfra (`oi_`) functions utilised to recategorise and add value to OSM infrastructure network data. <br><br> 
Each openinfra function is defined and described below. 
<br><br>

#### Function: `oi_recode_road_class` 
Below we can see the `recode_road_class` function. This function takes a SimpleFeatures ([sf](https://r-spatial.github.io/sf/index.html)) osm infrastructure network and re-classifies features based
on road classifications specified by [Chan and Cooper](https://www.nature.com/articles/s41598-019-55669-8) in the following [table](https://www.nature.com/articles/s41598-019-55669-8/tables/6).
<br><br>
[Chan and Cooper's](https://www.nature.com/articles/s41598-019-55669-8) work, *"Using road class as a replacement for predicted motorized traffic flow in spatial network models of cycling"*.
<br><br>
Cycling models require the simulation of motorised traffic in order to simulate motorised traffic movement to be considered in cycling models for route planning (cyclists won't enjoy being on a busy road full of traffic!).
<br><br>
To model a given area for cycling, simulated motorised traffic must be modelled for a circular area (∝r^2^) 20x that of the cyclists, as zonal Origin Destination (OD) data is used for the entire car trip (typical car journey range ~30km to a cyclists ~7km).
<br><br>
Accurately modelling motor traffic for such a larger area requires much more data, time, and money than that required to model for cyclists, this becomes even more of an issue when comparing budgets for cyclist modelling and motorised traffic modelling.
<br><br>
[Work](https://www.nature.com/articles/s41598-019-55669-8) by Chan and Cooper propose estimating road traffic based on road classes, as defined in the table above, negating the requirement for the costly and time consuming modelling of motorised traffic.

```{r function, class.source = 'fold-hide'}
# Define recode_road_class function
oi_recode_road_class <- function(osm_sf) {
  # browser() Uncomment this to perform function debugging 
  
  # Created road_class columns
  osm_recat = osm_sf %>%
    # Creates road_class column
    dplyr::mutate(oi_road_class = dplyr::case_when(
      # (7) - Motorways
      highway %in% c("motorway", "motorway_link") ~ "7",
      # (6/5) - Dual Carriageways resi & non-resi
      highway %in% c("trunk", "trunk_link") ~ "6/5",
      # (4) - Primary Roads
      highway %in% c("primary", "primary_link") | (highway == "trunk" & oneway == "F") ~ "4",
      # (3) - Secondary Roads
      highway %in% c("secondary", "secondary_link") ~ "3",
      # (2) - Tertiary Roads
      highway %in% c("tertiary", "tertiary_link") ~ "2",
      # (1) - Local Roads
      highway %in% c("living_street", "residential", "unclassified") ~ "1",
      # (0) - Traffic-free Paths
      highway == "cycleway" ~ "0"
    )) %>%
    
    # Creates road_description columns
    dplyr::mutate(oi_road_desc = dplyr::case_when(
      # (7) - Motorways
      highway %in% c("motorway", "motorway_link") ~ "Motorways",
      # (6/5) - Dual Carriageways resi & non-resi
      (highway %in% c("trunk", "trunk_link")) & (oneway %in% c("yes", "-1", "reversible", "alternating")) ~ "Dual Carriageways (R&NR)",
      # (4) - Primary Roads
      highway %in% c("primary", "primary_link") | (highway %in% c("trunk", "trunk_link")) & (! oneway %in% c("yes", "-1", "reversible", "alternating")) ~ "Primary Roads",
      # (3) - Secondary Roads
      highway %in% c("secondary", "secondary_link") ~ "Secondary Roads",
      # (2) - Tertiary Roads
      highway %in% c("tertiary", "tertiary_link") ~ "Tertiary Roads",
      # (1) - Local Roads
      highway %in% c("living_street", "residential", "unclassified") ~ "Residential / Local Roads",
      # (0) - Traffic-free Paths
      highway == "cycleway" ~ "Cycleway"
    )) %>%
    
    # Removes features that have not been recodeed to a road_class value
    dplyr::filter(!is.na(oi_road_class))
}
```

<br><br>

As discussed, the above function was defined defined based on the following table from Chan and Cooper: 

Road Class | Description | Selection from OSM
-- | -- | --
7 | Motorways | `highway = motorway` **OR** `highway = motorway_link`
6 | Non-residential Dual Carriageways | `highway =  trunk` **OR** `highway = trunk_link` **AND** `oneway = yes`*& manual classification needed*
5 | Residential Dual Carriageways | `highway =  trunk` **OR** `highway =  trunk_link` **AND** `oneway = yes` *& manual classification needed*
4 | Primary Roads | (`highway =  primary` **OR** `highway = primary_link` **OR** `highway = trunk`) **AND** `oneway != yes`)
3 | Secondary Roads | `highway =  secondary` **OR** `highway =  secondary_link`
2 | Tertiary Roads | `highway = tertiary` **OR** `highway = tertiary_link`
1 | Local Roads | `highway = living_street` **OR** `highway = residential` **OR** `highway = unclassified`
0 | Traffic-free Paths | `highway = cycleway`
<br><br>

#### Function: `oi_active_cycle`

Adds column `oi_active_cycle` with values `"yes"|"no"` depending on whether or not a way is cyclable by cyclists. 

```{r function2}
oi_active_cycle = function(osm_sf, remove=FALSE){
  #browser() # Uncomment to debug
  osm_sf_cycle = osm_sf %>% dplyr::mutate(oi_cycle = dplyr::case_when(
    
    # Highway cannot be NA
    is.na(highway) ~ "no",
    
    # Highway values not appropriate for cycling
    highway %in% c('abandoned', 'bus_guideway', 'byway', 'construction', 
                   'corridor', 'elevator', 'fixme', 'escalator', 'gallop', 
                   'historic', 'no', 'planned', 'platform', 'proposed', 
                   'raceway', 'steps') 
    ~ "no",
    
    # Create two cases to catch features typically not allowed for cyclists, but have been flagged appropriate:
    # 1 - If highway = "bad highway values" BUT bicycle = "good bicycle values" then assign ~ "yes",
    (highway %in% c('motorway', 'motorway_link', 'footway', 'bridleway','pedestrian') & bicycle %in% c('yes', 'designated', 'permissive', 'destination')) ~ "yes",
    ((highway == "footway") & (! bicycle %in% c("no", "dismount", "private"))) & (! access %in% c("private", "no", "permit")) ~ "yes",
    
    # 2 - Assign highway = "bad highway values" ONLY as ~ "no". Ways that are appropriate for cyclists will already be assigned "yes" from above
    highway %in% c('motorway', 'motorway_link', 'footway', 'bridleway','pedestrian') ~ "no",
    
    # Way must have access rights
    access %in% c('private', 'no') ~ "no",
    
    # Way must not bar cyclists
    bicycle %in% c('no', 'private', 'ue_sidepath', 'restricted') ~ "no", 
    
    # Way must not contain "private" within the service tag
    grepl("private", service) ~ "no",

  ))
  
  # Case_when above should have added "no" to all inappropriate features, now 
  # find features that do not contain "no" and set as "yes"
  osm_sf_cycle$oi_cycle[is.na(osm_sf_cycle$oi_cycle)] = "yes"
  
  # If remove = TRUE, filter out features that have oi_cycle == "no"
  if (remove){
    osm_sf_cycle = osm_sf_cycle %>% dplyr::filter(osm_sf_cycle$oi_cycle == "yes")
  }
  return(osm_sf_cycle)
}
```
<br><br>

#### Function: `oi_active_walk`

Adds the column `oi_active_walk` with values `"yes"|"no"` depending on whether or not a way is walkable by pedestrians or not.

```{r}
oi_active_walk = function(osm_sf, remove = FALSE){
  #browser() #<-- Uncomment to debug function.
  osm_sf_walking = osm_sf %>% dplyr::mutate(oi_walk = dplyr::case_when(
    
    # Highway tag cannot be NA
    is.na(highway) ~ "no",
    
    # Highway tag cannot have un-walkable values
    highway %in% c('abandoned', 'bus_guideway', 'byway', 'construction', 
                   'corridor', 'elevator', 'fixme', 'escalator', 'gallop', 
                   'historic', 'no', 'planned', 'platform', 'proposed',
                   'raceway', 'motorway', 'motorway_link') 
    ~ "no",
    
    # Hihgway tag cannot be a cycleway UNLESS walking is permitted
    ((highway == "cycleway") & (foot %in% c('yes', 'designated', 'permissive', 'destination'))) ~ "yes",
    # Below catches highway == cycleway and foot != values below INCLUDING NAs. 
    ((highway == "cycleway") & (! foot %in% c('yes', 'designated', 'permissive', 'destination'))) ~ "no",
    
    (highway %in% c("footway", "pedestrian", "path")) & (! foot %in% c("no", "private")) & (! access %in% c("private", "no")) ~ "yes",
    
    # Access cannot be restricted
    ((access %in% c('private', 'no')) & (foot == "yes")) ~ "yes",
    ((access %in% c('private', 'no'))) ~ "no",
    
    # Foot usage must be permitted,
    foot %in% c('private', 'no', 'use_sidepath', 'restricted') ~ "no",
    
    # Service value does not contain "private"
    ((grepl("private", service)) & (foot == "yes")) ~ "yes",
    ((grepl("private", service)) & (foot != "yes")) ~ "no",
    
  ))
  
  # find features that do not contain "no" and set as "yes"
  osm_sf_walking$oi_walk[is.na(osm_sf_walking$oi_walk)] = "yes"
  
  # If remove = TRUE, filter out features that have oi_walking == "no"
  if (remove){
    osm_sf_walking = osm_sf_walking %>% dplyr::filter(osm_sf_walking$oi_walk == "yes")
  }
  
  return(osm_sf_walking)
}
```
<br><br>

#### Function: `oi_clean_maxspeed_uk`

Adds column `oi_maxspeed` that contains cleaned maxspeed values from OSM features, where the maxspeed field exists. 

```{r}
oi_clean_maxspeed_uk = function(osm_sf, no_NA = FALSE, del = FALSE) {
  
  # Define NOT IN 
  `%!in%` = Negate(`%in%`)
  
  osm_clean = osm_sf %>%
    dplyr::mutate(oi_maxspeed = dplyr::case_when(
      # maxspeed == national, when on motorway
      (maxspeed == "national" & highway %in% c("motorway", "motorway_link")) ~ "70 mph",
      
      # maxspeed == national, when NOT on motorway
      (maxspeed == "national" & highway %!in% c("motorway", "motorway_link")) ~ "60 mph",  
      
      # maxspeed == national, when on standard (i.e Non-Residential) dual carriageway
      (maxspeed == "national" & highway %in% c("trunk", "trunk_link")) ~ "70 mph",
      
      # maxspeed == (20|30|40|50|60|70 --> + mph)
      maxspeed == "20" ~ "20 mph",
      maxspeed == "30" ~ "30 mph",
      maxspeed == "40" ~ "40 mph",
      maxspeed == "50" ~ "50 mph",
      maxspeed == "60" ~ "60 mph",
      maxspeed == "70" ~ "70 mph",
      
      # Already cleaned speeds (to stop mutate missing these)
      maxspeed == "20 mph" ~ "20 mph",
      maxspeed == "30 mph" ~ "30 mph",
      maxspeed == "40 mph" ~ "40 mph",
      maxspeed == "50 mph" ~ "50 mph",
      maxspeed == "60 mph" ~ "60 mph",
      maxspeed == "70 mph" ~ "70 mph",
    )) 
  
  if (no_NA){
    # if TURE, will remove features if their oi_maxspeed == NA
    osm_clean = osm_clean %>% dplyr::filter(!is.na(oi_maxspeed))
  }
  
  if (del){
    # If TRUE, will delete original `maxspeed` column
    osm_clean = subset(osm_clean, select = -c(maxspeed))
  } 

  return(osm_clean)
  }

```
<br><br>


<br><br>

#### Function: `oi_is_lit`

Adds column `oi_is_lit` with values `"yes"|"no"|"yes- LED"|"no -LED"|"maybe"` depending on whether the OSM way is lit or not, and if the lighting is LED or not. The value `"maybe"` implies that there is a lack of data to be able to distinguish - this is likely "yes" in built up urban areas, and "no" for more rural areas.

```{r}
oi_is_lit = function(osm_sf, remove=FALSE){
  
  # Select only the ways that have a highway value (not train tracks etc.)
  osm_sf = osm_sf %>% dplyr::filter(! is.na(osm_sf$highway))
  
  # Recategorise the data
  osm_sf_lit = osm_sf %>% dplyr::mutate(oi_is_lit = dplyr::case_when( 
    # If lit=* is not a unlit value - set as yes.
    (! lit %in% c("no", "disused") & ! is.na(lit)) ~ "yes",
    # If way is known to be unlit
    lit %in% c("no", "disued") ~ "no",
    
    # Used if street light is an LED (increasing popularity)
    lit_by_led == "yes" ~ "yes - LED",
    lit_by_led == "no" ~ "no - LED",
    ))
  
  # Finally - all remaining N/A are unknown as either lit or unlit.
  osm_sf_lit$oi_is_lit[is.na(osm_sf_lit$oi_is_lit)] = "maybe"
  
  # If remove = TRUE, filter out features that have oi_is_lit == "no"
  if (remove){
    osm_sf_lit = osm_sf_lit %>% dplyr::filter(osm_sf_lit$oi_is_lit %in% c("yes", "yes - LED", "maybe"))
  }
  
  return(osm_sf_lit)
}
```

<br><br>
